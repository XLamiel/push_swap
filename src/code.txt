========================================
ARCHIVO: /home/xl/gitroot/push_swap2/src/ps_basic_mov.c
========================================
#include "push_swap.h"

// basic movements
void	swap(t_stack *stack)
{
	int		temp;
	t_node	*first;
	t_node	*second;

	if (stack->size < 2)
		return ;
	first = stack->top;
	second = first->next;
	temp = first->value;
	first->value = second->value;
	second->value = temp;
}

void	rotate(t_stack *stack)
{
	t_node	*first;
	t_node	*last;

	if (stack->size < 2)
		return ;
	first = stack->top;
	last = stack->top;
	while (last->next)
		last = last->next;
	stack->top = first->next;
	first->next = NULL;
	last->next = first;
}

void	reverse_rotate(t_stack *stack)
{
	t_node	*prev;
	t_node	*cur;

	if (stack->size < 2)
		return ;
	prev = NULL;
	cur = stack->top;
	while (cur->next)
	{
		prev = cur;
		cur = cur->next;
	}
	if (prev)
		prev->next = NULL;
	cur->next = stack->top;
	stack->top = cur;
}


========================================
ARCHIVO: /home/xl/gitroot/push_swap2/src/ps_cost_calc.c
========================================

#include "push_swap.h"

int	calc_moves(int size, int pos)
{
	if (pos > size / 2)
		return (pos - size);
	return (pos);
}

int	calc_total_cost(int a_moves, int b_moves)
{
	if ((a_moves > 0 && b_moves > 0) || (a_moves < 0 && b_moves < 0))
	{
		if (abs(a_moves) > abs(b_moves))
			return (abs(a_moves));
		return (abs(b_moves));
	}
	return (abs(a_moves) + abs(b_moves));
}

t_cost	evaluate_move(t_stack *a, t_stack *b, int value, int pos_b)
{
	t_cost	res;
	int		pos_a;

	pos_a = get_a_target_pos(a, value);
	res.a_moves = calc_moves(a->size, pos_a);
	res.b_moves = calc_moves(b->size, pos_b);
	res.cost = calc_total_cost(res.a_moves, res.b_moves);
	return (res);
}


========================================
ARCHIVO: /home/xl/gitroot/push_swap2/src/ps_help_test.c
========================================

#include "push_swap.h"

// Funciones para imprimir stacks
void	print_stack(t_stack *stack)
{
	t_node	*current;

	if (!stack || !stack->top)
	{
		ft_printf("Empty\n");
		return;
	}
	current = stack->top;
	while (current) {
		ft_printf("%d ", current->value);
		current = current->next;
	}
	ft_printf("\n");
}

void	print_stacks(t_stack *a, t_stack *b)
{
	ft_printf("--- Stacks ---\n");
	ft_printf("Stack A: ");
	print_stack(a);
	ft_printf("Stack B: ");
	print_stack(b);
	ft_printf("--------------\n");
}


========================================
ARCHIVO: /home/xl/gitroot/push_swap2/src/ps_print_mov_p.c
========================================

#include "push_swap.h"

void	pa(t_stack *a, t_stack *b)
{
	int	val;

	if (b->size == 0)
		return ;
	if (pop(b, &val))
	{
		push(a, val);
		ft_printf("pa\n");
	}
}

void	pb(t_stack *a, t_stack *b)
{
	int	val;

	if (a->size == 0)
		return ;
	if (pop(a, &val))
	{
		push(b, val);
		ft_printf("pb\n");
	}
}


========================================
ARCHIVO: /home/xl/gitroot/push_swap2/src/ps_print_mov_r.c
========================================

#include "push_swap.h"

// Print functions ra, rb, rr

void	ra(t_stack *a)
{
	rotate(a);
	ft_printf("ra\n");
}

void	rb(t_stack *b)
{
	rotate(b);
	ft_printf("rb\n");
}

void	rr(t_stack *a, t_stack *b)
{
	rotate(a);
	rotate(b);
	ft_printf("rr\n");
}


========================================
ARCHIVO: /home/xl/gitroot/push_swap2/src/ps_print_mov_rr.c
========================================

#include "push_swap.h"

// Print functions rra, rrb, rrr

void	rra(t_stack *a)
{
	reverse_rotate(a);
	ft_printf("rra\n");
}

void	rrb(t_stack *b)
{
	reverse_rotate(b);
	ft_printf("rrb\n");
}

void	rrr(t_stack *a, t_stack *b)
{
	reverse_rotate(a);
	reverse_rotate(b);
	ft_printf("rrr\n");
}


========================================
ARCHIVO: /home/xl/gitroot/push_swap2/src/ps_print_mov_s.c
========================================

#include "push_swap.h"

// Print functions sa, sb, ss

void	sa(t_stack *a)
{
	swap(a);
	ft_printf("sa\n");
}

void	sb(t_stack *b)
{
	swap(b);
	ft_printf("sb\n");
}

void	ss(t_stack *a, t_stack *b)
{
	swap(a);
	swap(b);
	ft_printf("ss\n");
}


========================================
ARCHIVO: /home/xl/gitroot/push_swap2/src/ps_sort_exec_mov.c
========================================

#include "push_swap.h"

void	execute_double_moves(t_stack *a, t_stack *b, int *cost_a, int *cost_b)
{
	while (*cost_a > 0 && *cost_b > 0)
	{
		rr(a, b);
		(*cost_a)--;
		(*cost_b)--;
	}
	while (*cost_a < 0 && *cost_b < 0)
	{
		rrr(a, b);
		(*cost_a)++;
		(*cost_b)++;
	}
}

void	execute_moves_a(t_stack *a, int *cost_a)
{
	while (*cost_a > 0)
	{
		ra(a);
		(*cost_a)--;
	}
	while (*cost_a < 0)
	{
		rra(a);
		(*cost_a)++;
	}
}

void	execute_moves_b(t_stack *b, int *cost_b)
{
	while (*cost_b > 0)
	{
		rb(b);
		(*cost_b)--;
	}
	while (*cost_b < 0)
	{
		rrb(b);
		(*cost_b)++;
	}
}

void	execute_moves(t_stack *a, t_stack *b, int cost_a, int cost_b)
{
	execute_double_moves(a, b, &cost_a, &cost_b);
	execute_moves_a(a, &cost_a);
	execute_moves_b(b, &cost_b);
}


========================================
ARCHIVO: /home/xl/gitroot/push_swap2/src/ps_sort_large.c
========================================

#include "push_swap.h"

void	move_all_but_three(t_stack *a, t_stack *b)
{
	while (a->size > 3)
		pb(a, b);
	sort_three(a);
}

t_cost	find_best_move(t_stack *a, t_stack *b)
{
	int		pos_b;
	t_node	*cur;
	t_cost	best;
	t_cost	cur_cost;

	pos_b = 0;
	cur = b->top;
	best.cost = INT_MAX;
	while (cur)
	{
		cur_cost = evaluate_move(a, b, cur->value, pos_b);
		if (cur_cost.cost < best.cost)
			best = cur_cost;
		cur = cur->next;
		pos_b++;
	}
	return (best);
}

void	move_back_to_a(t_stack *a, t_stack *b)
{
	t_cost	best;

	while (b->size > 0)
	{
		best = find_best_move(a, b);
		execute_moves(a, b, best.a_moves, best.b_moves);
		pa(a, b);
	}
}

void	sort_large_stack(t_stack *a, t_stack *b)
{
	move_all_but_three(a, b);
	move_back_to_a(a, b);
}

void	sort_stack(t_stack *a, t_stack *b)
{
	if (a->size <= 3)
		sort_three(a);
	else
		sort_large_stack(a, b);
}


========================================
ARCHIVO: /home/xl/gitroot/push_swap2/src/ps_sort_target.c
========================================

#include "push_swap.h"

// Caso 1: encontrar posición del mínimo en la lista
int	find_min_pos(t_stack *a, int min_val)
{
	t_node	*current;
	int		pos;

	current = a->top;
	pos = 0;
	while (current)
	{
		if (current->value == min_val)
			return (pos);
		current = current->next;
		pos++;
	}
	return (0);
}

// Caso 2: encontrar la posición entre dos valores consecutivos
int	find_insert_pos(t_stack *a, int val)
{
	t_node	*current;
	int		pos;

	current = a->top;
	pos = 0;
	while (current && current->next)
	{
		if (val > current->value && val < current->next->value)
			return (pos + 1);
		current = current->next;
		pos++;
	}
	return (0);
}

// Función principal que delega en los casos anteriores
int	get_a_target_pos(t_stack *a, int val)
{
	int	min_val;
	int	max_val;

	get_min_max(a, &min_val, &max_val);
	if (val < min_val || val > max_val)
		return (find_min_pos(a, min_val));
	else
		return (find_insert_pos(a, val));
}


========================================
ARCHIVO: /home/xl/gitroot/push_swap2/src/ps_sort_three.c
========================================

#include "push_swap.h"

void	get_top_three(t_stack *a, int *v1, int *v2, int *v3)
{
	*v1 = a->top->value;
	*v2 = a->top->next->value;
	*v3 = a->top->next->next->value;
}

void	sort_three(t_stack *a)
{
	int	v1;
	int	v2;
	int	v3;

	get_top_three(a, &v1, &v2, &v3);
	if (v1 > v2 && v2 < v3 && v1 > v3)
		ra(a);
	else if (v1 > v2 && v2 > v3)
	{
		sa(a);
		rra(a);
	}
	else if (v1 < v2 && v2 > v3 && v1 > v3)
		rra(a);
	else if (v1 < v2 && v2 > v3 && v1 < v3)
	{
		sa(a);
		ra(a);
	}
	else if (v1 > v2 && v2 < v3)
		sa(a);
}


========================================
ARCHIVO: /home/xl/gitroot/push_swap2/src/ps_sort_utils.c
========================================

#include "push_swap.h"

int	find_min_position(t_stack *a, int *min_val)
{
	t_node	*current;
	int		min_pos;
	int		pos;

	min_pos = 0;
	pos = 0;
	current = a->top;
	*min_val = INT_MAX;
	while (current)
	{
		if (current->value < *min_val)
		{
			*min_val = current->value;
			min_pos = pos;
		}
		current = current->next;
		pos++;
	}
	return (min_pos);
}

void	rotate_value_to_top(t_stack *a, int value, int pos)
{
	if (pos <= a->size / 2)
	{
		while (a->top->value != value)
			ra(a);
	}
	else
	{
		while (a->top->value != value)
			rra(a);
	}
}

void	rotate_min_top(t_stack *a)
{
	int	min_val;
	int	min_pos;

	min_pos = find_min_position(a, &min_val);
	rotate_value_to_top(a, min_val, min_pos);
}


========================================
ARCHIVO: /home/xl/gitroot/push_swap2/src/ps_stack_init.c
========================================

#include "push_swap.h"

void	init_stack(t_stack *s)
{
	s->top = NULL;
	s->size = 0;
}

void	load_stack(t_stack *a, int argc, char **argv)
{
	int	i;

	i = argc - 1;
	while (i >= 1)
	{
		push(a, ft_atoi(argv[i]));
		i--;
	}
}

void	free_stack(t_stack *s)
{
	int	val;

	while (s->top)
		pop(s, &val);
}


========================================
ARCHIVO: /home/xl/gitroot/push_swap2/src/ps_stack_ops1.c
========================================

#include "push_swap.h"

t_node	*new_node(int value)
{
	t_node	*node;

	node = malloc(sizeof(t_node));
	if (!node)
		return (NULL);
	node->value = value;
	node->next = NULL;
	return (node);
}

void	push(t_stack *stack, int value)
{
	t_node	*node;

	node = new_node(value);
	if (!node)
		return ;
	node->next = stack->top;
	stack->top = node;
	stack->size++;
}

int	pop(t_stack *stack, int *val)
{
	t_node	*tmp;

	if (!stack->top)
		return (0);
	tmp = stack->top;
	*val = tmp->value;
	stack->top = tmp->next;
	free(tmp);
	stack->size--;
	return (1);
}


========================================
ARCHIVO: /home/xl/gitroot/push_swap2/src/ps_stack_ops2.c
========================================

#include "push_swap.h"

void	get_min_max(t_stack *stack, int *min, int *max)
{
	t_node	*current;

	*min = INT_MAX;
	*max = INT_MIN;
	current = stack->top;
	while (current)
	{
		if (current->value < *min)
			*min = current->value;
		if (current->value > *max)
			*max = current->value;
		current = current->next;
	}
}

int	is_sorted(t_stack *a)
{
	t_node	*cur;

	if (a->size <= 1)
		return (1);
	cur = a->top;
	while (cur && cur->next)
	{
		if (cur->value > cur->next->value)
			return (0);
		cur = cur->next;
	}
	return (1);
}


========================================
ARCHIVO: /home/xl/gitroot/push_swap2/src/push_swap.c
========================================

#include "push_swap.h"

int	main(int argc, char **argv)
{
	t_stack	a;
	t_stack	b;

	if (argc < 2)
		return (1);
	init_stack(&a);
	init_stack(&b);
	load_stack(&a, argc, argv);
	if (!is_sorted(&a))
		sort_stack(&a, &b);
	rotate_min_top(&a);
	print_stacks(&a, &b);
	free_stack(&a);
	free_stack(&b);
	return (0);
}


